heatmap.2(mat_norm,Colv = T,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png", height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png", height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.5,cex.col = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png", height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.5,cexCol = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png", height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png",height = 8, width = 6, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png",height = 8, width = 6, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8,col=color.palette, breaks = breaks)
dev.off()
png("../../output/DE_pseudotime/tfs_song.png",height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8,col=color.palette, breaks = breaks)
dev.off()
dat = read.csv('../../data/vpl195A.result.table.csv', stringsAsFactors = F)
antler_obj= readRDS("../../output/gene_modules/all_data/antler_obj.RDS")
modules = antler_obj$topCorr_DR$genemodules
samples = names(dat)[65:53]
mat = as.matrix(dat[,samples])
rownames(mat) = dat$mgi_symbol
log_mat = log1p(mat)
modules[[16]][!(modules[[16]] %in% rownames(log_mat))]
# "Cemip2"
genes = modules[[16]][modules[[16]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
library(matrixStats)
mat_norm = mat_selected - rowMeans(mat_selected)
head(dat)
dat[,dat$mgi_symbol == "Csde1"]
dat[dat$mgi_symbol == "Csde1",]
grep("padj",rownames(dat))
grep("padj",colnames(dat))
colnames(dat)[grep("padj",colnames(dat))]
colnames(dat)[grep("padj_D",colnames(dat))]
padj = colnames(dat)[grep("padj_D",colnames(dat))]
dat[dat$mgi_symbol == "Csde1",padj]
dat[dat$mgi_symbol == "Peg12",padj]
dat[dat$mgi_symbol == "Sox11",padj]
dat[dat$mgi_symbol == "Hmga2",padj]
dat[dat$mgi_symbol == "Set",padj]
tfs = read.csv("../../output/DE_pseudotime/tf_list.csv")
mat_selected = log_mat[as.character(tfs$x),]
mat_norm = mat_selected - rowMeans(mat_selected)
library(gplots)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
png("../../output/DE_pseudotime/tfs_song.png",height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8,col=color.palette, breaks = breaks)
dev.off()
dat[dat$mgi_symbol == "Set",padj] < 0.05
sum(dat[dat$mgi_symbol == "Set",padj] < 0.05)
rowSums(dat[dat$mgi_symbol == "Set",padj] < 0.05)
rowSums(dat[,padj] < 0.05)
dat = read.csv('../../data/vpl195A.result.table.csv', stringsAsFactors = F)
antler_obj= readRDS("../../output/gene_modules/all_data/antler_obj.RDS")
modules = antler_obj$topCorr_DR$genemodules
samples = names(dat)[65:53]
padj = colnames(dat)[grep("padj_D",colnames(dat))]
rowSums(dat[,padj] < 0.05)
dat = dat[rowSums(dat[,padj] < 0.05)>0,]
mat = as.matrix(dat[,samples])
rownames(mat) = dat$mgi_symbol
log_mat = log1p(mat)
modules[[16]][!(modules[[16]] %in% rownames(log_mat))]
dim(dat)
rowSums(dat[,padj] < 0.05)
dat[dat$mgi_symbol == "Peg12",padj]
antler_obj= readRDS("../../output/gene_modules/all_data/antler_obj.RDS")
modules = antler_obj$topCorr_DR$genemodules
dat = read.csv('../../data/vpl195A.result.table.csv', stringsAsFactors = F)
samples = names(dat)[65:53]
padj = colnames(dat)[grep("padj_D",colnames(dat))]
dat = dat[rowSums(dat[,padj] < 0.05)>0,]
mat = as.matrix(dat[,samples])
rownames(mat) = dat$mgi_symbol
log_mat = log1p(mat)
modules[[16]][!(modules[[16]] %in% rownames(log_mat))]
# "Cemip2"
#[1] "Arglu1"  "Arl14ep" "Birc6"   "Cemip2"  "Crebbp"  "Gmps"    "Hnrnpa0" "Klhl9"   "Krit1"   "Lrrc58"  "Mau2"    "Ogdhl"   "Pfas"
#[14] "Skil"    "Sox11"   "Srek1"   "Tbck"    "Tspyl1"  "Tug1"    "Usp37"   "Zfhx3"   "Zfp691"  "Zfp868"
genes = modules[[16]][modules[[16]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
library(matrixStats)
mat_norm = mat_selected - rowMeans(mat_selected)
library(gplots)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/song_early_significant.pdf", width = 20, height = 18)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_selected,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
mat_norm
library(gplots)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/song_early_significant.pdf", width = 20, height = 18)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_selected,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
modules[[16]][!(modules[[16]] %in% rownames(log_mat))]
imag(mat_norm)
image(mat_norm)
dat = read.csv('../../data/vpl195A.result.table.csv', stringsAsFactors = F)
samples = names(dat)[65:53]
padj = colnames(dat)[grep("padj_D",colnames(dat))]
dim(dat)
dat = dat[rowSums(dat[,padj] < 0.05)>0,]
dim(dat)
mat = as.matrix(dat[,samples])
rownames(mat) = dat$mgi_symbol
dat = read.csv('../../data/vpl195A.result.table.csv', stringsAsFactors = F)
samples = names(dat)[65:53]
padj = colnames(dat)[grep("padj_D",colnames(dat))]
dat = dat[rowSums(dat[,padj] < 0.05)>0,]
mat = as.matrix(dat[,samples])
rownames(mat) = dat$mgi_symbol
log_mat = log1p(mat)
library(gplots)
early_late= read.csv("/home/anna/Documents/trajectoryGeometryAnalysis/early_late_genes.csv")
early_late = early_late$x
early_late = early_late[early_late %in% rownames(log_mat)]
#early_late = early_late[length(early_late):1]
mat_selected = log_mat[as.character(early_late),]
mat_norm = mat_selected - rowMeans(mat_selected)
library(gplots)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
png("../../output/trajectory_geometry/early_late_neurogenic_direction.png",height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8,col=color.palette, breaks = breaks)
dev.off()
mat_selected = log_mat[as.character(early_late),4:ncol(log_mat)]
mat_norm = mat_selected - rowMeans(mat_selected)
library(gplots)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
png("../../output/trajectory_geometry/early_late_neurogenic_direction_div4_onwards.png",height = 8, width = 4, units = "in", res = 300)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = F, symbreak=TRUE, trace='none',
cexRow = 0.8,cexCol = 0.8,col=color.palette, breaks = breaks)
dev.off()
genes = modules[[65]][modules[[65]] %in% rownames(log_mat)]
antler_obj= readRDS("../../output/gene_modules/all_data/antler_obj.RDS")
modules = antler_obj$topCorr_DR$genemodules
genes = modules[[65]][modules[[65]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
mat_norm = mat_selected - rowMeans(mat_selected)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/chat_module_significant.pdf", width = 20, height = 18)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
genes = modules[[55]][modules[[55]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
mat_norm = mat_selected - rowMeans(mat_selected)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/nos1_module_significant.pdf", width = 20, height = 18)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
genes = modules[[65]][modules[[65]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
mat_norm = mat_selected - rowMeans(mat_selected)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/chat_module_significant.pdf", width = 10, height = 10)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
genes = modules[[55]][modules[[55]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
mat_norm = mat_selected - rowMeans(mat_selected)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/nos1_module_significant.pdf", width = 10, height = 10)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
genes = modules[[27]][modules[[27]] %in% rownames(log_mat)]
mat_selected = log_mat[genes,]
mat_norm = mat_selected - rowMeans(mat_selected)
#create heatmap
extreme = (max(abs(min(mat_norm)),abs(max(mat_norm))))
breaks = seq(from=-extreme, to=max(extreme), length.out=100)
pdf("../../output/module_27_significant.pdf", width = 10, height = 10)
color.palette = colorRampPalette(c("blue", "white", "red"))
heatmap.2(mat_norm,Colv = F,Rowv = T, symbreak=TRUE, trace='none',
cexRow = 0.5, margins =c(12,9),col=color.palette, breaks = breaks)
dev.off()
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(traj1Data, metric, average, traj2Data)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart)
}
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(traj1Data, metric, average, traj2Data)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart))
}
## ###################################################
## calculate -log10(pValue)
pValues$logPValue = -log10(pValues$pValue)
## ###################################################
## create violin plot of distances
distancePlot = ggplot(branchPointValues[branchPointValues$type != "Random",], aes(x=trajectoryStart, y=value)) +
geom_violin() + geom_boxplot(width=0.1) + xlab('trajectory start') + ylab('mean distance')
## ###################################################
## create line plot of -log10 transformed p-values
pValuePlot = ggplot(pValues, aes(x=trajectoryStart, y=logPValue, group=1)) + geom_line( size = 1.5)  +
geom_point(size = 3) + xlab('Trajectory start') + ylab('-log10(p-value)')
return(list(branchPointValues = branchPointValues, pValues = pValues,
distancePlot = distancePlot, pValuePlot = pValuePlot))
}
setwd("/home/anna/Documents/TrajectoryGeometry")
devtools::load_all()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#load packages
library(TrajectoryGeometry)
library(RColorBrewer)
library(dplyr)
library(ggplot2)
#set up colors
colors = colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
#set random seed
set.seed(42)
#filter matrices
cholAttributes = singleCellMatrix[!is.na(cholPseudoTime),]
hepAttributes = singleCellMatrix[!is.na(hepPseudoTime),]
#filter pseudotime values
cholPseudoTime = cholPseudoTime[!is.na(cholPseudoTime)]
hepPseudoTime = hepPseudoTime[!is.na(hepPseudoTime)]
#normalise pseudotime values to 100
cholPseudoTimeNormalised = cholPseudoTime  %>% {100*((. - min(.))/(max(.) - min(.)))}
hepPseudoTimeNormalised = hepPseudoTime %>% {100*((. - min(.))/(max(.) - min(.)))}
distances = distanceBetweenTrajectories(cholAttributes, cholPseudoTime,
hepAttributes)
plot(distances$pseudotime, distances$distance, xlab = "cholangiocyte pseudotime", ylab = "minimum distance")
branchPointResults = analyseBranchPoint(cholAttributes[,1:3],
cholPseudoTime,
randomizationParams = c('byPermutation',
'permuteWithinColumns'),
statistic = "mean",
start = 0,
stop = 50,
step = 5,
nSamples = 100,
N = 1)
branchPointStats = visualiseBranchPointStats(branchPointResults)
devtools::load_all()
branchPointStats = visualiseBranchPointStats(branchPointResults)
devtools::load_all()
visualiseBranchPointStatsTest = function(branchPointData,
average){
if(! class(branchPointData) == 'list')
stop('visualiseBranchPointStats expects branchPointData to be a list')
if(! sum(names(branchPointData[[names(branchPointData)[[1]]]][[1]])  == c("pValue","sphericalData","randomDistances","randomizationParams")) == 4)
stop('visualiseBranchPointStats expects branchPointData to be the output of analyseBranchPoint')
if(! average %in% c('median','mean'))
stop(paste("visualiseTrajectoryStats expects average to be",
"'median' or 'mean'"))
}
## ###################################################
#' Visualise Branch Point Stats
#'
#' This function creates plots and extracts statistics for analysing branch
#' points. It returns plots and underlying data for visualising distance metrics and
#' -log10 transformed pvalues (comparison to random trajectories) for trajectories with
#' different starting points.
#'
#' @param branchPointData - the result of analyseBranchPoint
#' @param average - if there are multiple distances available for each
#' sampled trajectory, calculate the average using "mean" or "median" (defaults to "mean").
#' @return a list containing:
#'  branchPointValues - dataframe containing data underlying distance plot in long format
#'  pValues- dataframe containing data underlying p-value plot in long format
#'  distancePlot - ggplot object, violin plots of distance metric for sampled paths
#'                 for different trajectory different starting points
#'  pValue - ggplot object, line plot of -log10 transformed p-valuesfor comparing sampled paths
#'           to random paths for different trajectory starting points
#' @importFrom ggplot2 ggplot geom_violin geom_boxplot geom_line, geom_point, labs aes
#' @export
#' @examples
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(branchPointData, average)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart))
}
## ###################################################
## calculate -log10(pValue)
pValues$logPValue = -log10(pValues$pValue)
## ###################################################
## create violin plot of distances
distancePlot = ggplot(branchPointValues[branchPointValues$type != "Random",], aes(x=trajectoryStart, y=value)) +
geom_violin() + geom_boxplot(width=0.1) + xlab('trajectory start') + ylab('mean distance')
## ###################################################
## create line plot of -log10 transformed p-values
pValuePlot = ggplot(pValues, aes(x=trajectoryStart, y=logPValue, group=1)) + geom_line( size = 1.5)  +
geom_point(size = 3) + xlab('Trajectory start') + ylab('-log10(p-value)')
return(list(branchPointValues = branchPointValues, pValues = pValues,
distancePlot = distancePlot, pValuePlot = pValuePlot))
}
branchPointStats = visualiseBranchPointStats(branchPointResults)
print(branchPointStats$distancePlot)
print(branchPointStats$pValuePlot)
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(branchPointData, average)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart))
}
## ###################################################
## calculate -log10(pValue)
pValues$logPValue = -log10(pValues$pValue)
## ###################################################
## create violin plot of distances
distancePlot$trajectoryStart = as.factor(distancePlot$trajectoryStart)
distancePlot = ggplot(branchPointValues[branchPointValues$type != "Random",], aes(x=trajectoryStart, y=value)) +
geom_violin() + geom_boxplot(width=0.1) + xlab('trajectory start') + ylab('mean distance')
## ###################################################
## create line plot of -log10 transformed p-values
pValuePlot = ggplot(pValues, aes(x=trajectoryStart, y=logPValue, group=1)) + geom_line( size = 1.5)  +
geom_point(size = 3) + xlab('Trajectory start') + ylab('-log10(p-value)')
return(list(branchPointValues = branchPointValues, pValues = pValues,
distancePlot = distancePlot, pValuePlot = pValuePlot))
}
branchPointStats = visualiseBranchPointStats(branchPointResults)
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(branchPointData, average)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart))
}
## ###################################################
## calculate -log10(pValue)
pValues$logPValue = -log10(pValues$pValue)
## ###################################################
## create violin plot of distances
branchPointValues$trajectoryStart = as.factor(distancePlot$trajectoryStart)
distancePlot = ggplot(branchPointValues[branchPointValues$type != "Random",], aes(x=trajectoryStart, y=value)) +
geom_violin() + geom_boxplot(width=0.1) + xlab('trajectory start') + ylab('mean distance')
## ###################################################
## create line plot of -log10 transformed p-values
pValuePlot = ggplot(pValues, aes(x=trajectoryStart, y=logPValue, group=1)) + geom_line( size = 1.5)  +
geom_point(size = 3) + xlab('Trajectory start') + ylab('-log10(p-value)')
return(list(branchPointValues = branchPointValues, pValues = pValues,
distancePlot = distancePlot, pValuePlot = pValuePlot))
}
branchPointStats = visualiseBranchPointStats(branchPointResults)
visualiseBranchPointStats = function(branchPointData,
average = "mean")
{
visualiseBranchPointStatsTest(branchPointData, average)
## ###################################################
## Set up dataframe which will be populated with data to plot in long format
branchPointValues = data.frame(type = character(), value = numeric(), trajectoryStart = numeric())
## ###################################################
## Set up dataframe to store pvalues
pValues = data.frame(trajectoryStart = numeric(),pValue = numeric())
## ###################################################
## Iterate through branch points
for (name in names(branchPointResults)){
trajectoryStart = as.numeric(name)
results = visualiseTrajectoryStats(branchPointResults[[name]], "distance", average = average)
values = results$values
values$trajectoryStart = trajectoryStart
branchPointValues = rbind(branchPointValues, values)
pValue = results$stats$p.value
pValues = rbind(pValues, data.frame(pValue = pValue, trajectoryStart = trajectoryStart))
}
## ###################################################
## calculate -log10(pValue)
pValues$logPValue = -log10(pValues$pValue)
## ###################################################
## create violin plot of distances
branchPointValues$trajectoryStart = as.factor(branchPointValues$trajectoryStart)
distancePlot = ggplot(branchPointValues[branchPointValues$type != "Random",], aes(x=trajectoryStart, y=value)) +
geom_violin() + geom_boxplot(width=0.1) + xlab('trajectory start') + ylab('mean distance')
## ###################################################
## create line plot of -log10 transformed p-values
pValuePlot = ggplot(pValues, aes(x=trajectoryStart, y=logPValue, group=1)) + geom_line( size = 1.5)  +
geom_point(size = 3) + xlab('Trajectory start') + ylab('-log10(p-value)')
return(list(branchPointValues = branchPointValues, pValues = pValues,
distancePlot = distancePlot, pValuePlot = pValuePlot))
}
branchPointStats = visualiseBranchPointStats(branchPointResults)
print(branchPointStats$pValuePlot)
print(branchPointStats$distancePlot)
