minFunction = function(x){
norm = Norm(x)
unitVector = x/norm
if (norm < 0.1){
return(100)
}
distances = findSphericalDistance(points,unitVector)
if (statistic == "max"){
return(max(distances))
}
if (statistic == "median"){
return(median(distances))
}
if (statistic == "mean"){
return(mean(distances))
}
}
## ###################################################
## Choose a possible center as a start for minimisation
meanPoint = colMeans(points)
optimStart = meanPoint/Norm(meanPoint)
## ###################################################
## Find center which minimises spherical distances.
minResult = optim(optimStart, minFunction, control = list(maxit = 1000))
center = minResult$par/Norm(minResult$par)
return(center)
}
findSphereClusterCenter = function(points,statistic,normalize=FALSE)
{
n = nrow(points)
## ###################################################
# Normalize if necessary:
if(normalize)
{
#center = center / Norm(center)  we have not found the
#center yet so cannot normalise it.
for(i in seq_len(n))
points[i,] = points[i,] / Norm(points[i,])
}
## ###################################################
## Function to be minimised
minFunction = function(x){
norm = Norm(x)
unitVector = x/norm
if (norm < 0.1){
return(100)
}
distances = findSphericalDistance(points,unitVector)
if (statistic == "max"){
return(max(distances))
}
if (statistic == "median"){
return(median(distances))
}
if (statistic == "mean"){
return(mean(distances))
}
}
## ###################################################
## Choose a possible center as a start for minimisation
meanPoint = colMeans(points)
optimStart = meanPoint/Norm(meanPoint)
## ###################################################
## Find center which minimises spherical distances.
minResult = optim(optimStart, minFunction, control = list(maxit = 1000))
center = minResult$par/Norm(minResult$par)
return(center)
}
points = c(c(1,2,3),c(4,5,6),c(7,8,9))
findSphereClusterCenter = function(points,statistic,normalize=FALSE)
{
n = nrow(points)
## ###################################################
# Normalize if necessary:
if(normalize)
{
#center = center / Norm(center)  we have not found the
#center yet so cannot normalise it.
for(i in seq_len(n))
points[i,] = points[i,] / Norm(points[i,])
}
## ###################################################
## Function to be minimised
minFunction = function(x){
norm = Norm(x)
unitVector = x/norm
if (norm < 0.1){
return(100)
}
distances = findSphericalDistance(points,unitVector)
if (statistic == "max"){
return(max(distances))
}
if (statistic == "median"){
return(median(distances))
}
if (statistic == "mean"){
return(mean(distances))
}
}
## ###################################################
## Choose a possible center as a start for minimisation
meanPoint = colMeans(points)
optimStart = meanPoint/Norm(meanPoint)
## ###################################################
## Find center which minimises spherical distances.
minResult = optim(optimStart, minFunction, control = list(maxit = 1000))
center = minResult$par/Norm(minResult$par)
return(center)
}
## ###################################################
#' Find the spherical distance from a given point to a
#' set of points.
#'
#' This function takes a point (typically a center) and
#' a set of points and finds the spherical distance between
#' the given point and each of the others.  If requested, it
#' will first normalize all of them.
#'
#' @param center - The proposed point from which distance to
#' the others should be measured.  This is a numerical vector
#' of length d.
#' @param points - The set of target points for which spherical
#' distance to the center should be calculated.  This is in the
#' form of a n x d matrix.
#' @param normalize - If this is set to TRUE, the function will start
#' by normalizing the input points.
#' @return This returns a vector of n spherical distances in
#' radians.
#' @export
findSphericalDistance = function(center,points,normalize=FALSE)
{
n = nrow(points)
## ###################################################
## Normalize if necessary:
if(normalize)
{
center = center / Norm(center)
for(i in seq_len(n))
points[i,] = points[i,] / Norm(points[i,])
}
## ###################################################
## Find spherical distances:
distances = numeric(n)
for(i in seq_len(n))
{
distances[i] = acos(dot(center,points[i,]))
}
return(distances)
}
findSphereClusterCenter(points,'mean')
points
points = rbind(c(1,2,3),(4,5,6),(7,8,9))
points = rbind(c(1,2,3),c(4,5,6),c(7,8,9))
findSphereClusterCenter(points,'mean')
@importFrom pracma Norm
library(pracma)
findSphereClusterCenter(points,'mean')
findSphereClusterCenter = function(points,statistic,normalize=FALSE)
{
n = nrow(points)
## ###################################################
# Normalize if necessary:
if(normalize)
{
#center = center / Norm(center)  we have not found the
#center yet so cannot normalise it.
for(i in seq_len(n))
points[i,] = points[i,] / Norm(points[i,])
}
## ###################################################
## Function to be minimised
minFunction = function(x){
norm = Norm(x)
unitVector = x/norm
if (norm < 0.1){
return(100)
}
distances = findSphericalDistance(unitVector,points)
if (statistic == "max"){
return(max(distances))
}
if (statistic == "median"){
return(median(distances))
}
if (statistic == "mean"){
return(mean(distances))
}
}
## ###################################################
## Choose a possible center as a start for minimisation
meanPoint = colMeans(points)
optimStart = meanPoint/Norm(meanPoint)
## ###################################################
## Find center which minimises spherical distances.
minResult = optim(optimStart, minFunction, control = list(maxit = 1000))
center = minResult$par/Norm(minResult$par)
return(center)
}
findSphereClusterCenter(points,'mean')
findSphericalDistance = function(center,points,normalize=FALSE)
{
n = nrow(points)
## ###################################################
## Normalize if necessary:
if(normalize)
{
center = center / Norm(center)
for(i in seq_len(n))
points[i,] = points[i,] / Norm(points[i,])
}
## ###################################################
## Find spherical distances:
distances = numeric(n)
for(i in seq_len(n))
{
distances[i] = acos(round(dot(center,points[i,]),7))
}
return(distances)
}
findSphereClusterCenter(points,'mean')
findSphereClusterCenter(points,'mean',normalize = TRUE)
